component thcv2 "Torch Height Control";

description
"""
Torch Height Control
Mesa THC > Encoder > Machinekit THC component

The Mesa THC sends a frequency based on the voltage detected to the encoder.
The velocity from the encoder is converted to volts with the velocity scale
parameter inside the THC component.

The THCAD card sends a frequency at 0 volts so the scale offset parameter is
used to zero the calculated voltage.

Component Functions
If enabled and torch is on and X + Y velocity is within tolerance of set speed
allow the THC to offset the Z axis as needed to maintain voltage.

If enabled and torch is off and the Z axis is moving up remove any correction
at a rate not to exceed the rate of movement of the Z axis.

If enabled and torch is off and there is no correction
pass the Z position and feed back untouched.

If not enabled pass the Z position and feed back untouched.

Physical Connections
.br
Plasma Torch Arc Voltage Signal => 6 x 487k 1% resistors => THC Arc Voltage In
.br
THC Frequency Signal => Encoder #0, pin A (Input)
.br
Plasma Torch Arc OK Signal => input pin
.br
output pin => Plasma Torch Start Arc Contacts

HAL Plasma Connections
.br
encoder.nn.velocity => thc.encoder-vel (tip voltage)
.br
motion.spindle-on => output pin (start the arc)
.br
thc.arc-ok <= motion.digital-in-00 <= input pin (arc ok signal)

HAL Motion Connections
.br
thc.requested-vel <= motion.requested-vel
.br
thc.current-vel <= motion.current-vel

""";

author "John Thornton";

license "GPLv2 or greater";

option singleton yes;

// Input Pins
pin_ptr in float encoder_vel    "Connect to hm2_5i20.0.encoder.00.velocity";
pin_ptr in float current_vel    "Connect to motion.current-vel";
pin_ptr in float requested_vel  "Connect to motion.requested-vel";
pin_ptr in float volts_requested "Tip Volts current_vel >= min_velocity requested";
pin_ptr in float vel_tol        "Velocity Tolerance (Corner Lock)";
pin_ptr in bit torch_on         "Connect to motion.spindle-on";
pin_ptr in bit arc_ok           "Arc OK from Plasma Torch";
pin_ptr in bit enable           "Enable the THC, if not enabled Z position is passed through";
pin_ptr in float z_pos_in       "Z Motor Position Command in from axis.n.motor-pos-cmd";

// Output Pins
pin_ptr out float z_pos_out     "Z Motor Position Command Out";
pin_ptr out float z_fb_out      "Z Position Feedback to Axis";
pin_ptr out float volts         "The Calculated Volts";
pin_ptr out bit vel_status      "When the THC thinks we are at requested speed";

// Parameters
pin_ptr io float vel_scale      "The scale to convert the Velocity signal to Volts";
pin_ptr io float scale_offset   "The offset of the velocity input at 0 volts";
pin_ptr io float velocity_tol   "The deviation percent from planned velocity";
pin_ptr io float voltage_tol    "The deviation of Tip Voltage before correction takes place";
pin_ptr io float correction_vel "The amount of change in user units per period to move Z to correct";

// Global Variables
variable hal_float_t offset = 0.0;
variable hal_float_t last_z_in = 0.0;

function _;

;;

#include "rtapi_math.h"

FUNCTION(_)
{
hal_float_t min_velocity;
hal_float_t z_diff;

    // convert encoder velocity to volts
    sf(volts, (gf(encoder_vel) - gf(scale_offset)) * gf(vel_scale));
    if(gf(volts) < 0.0)
        // make sure volts is not negative
        sf(volts, 0.0);

    if(gb(enable))
        {
        min_velocity = (gf(requested_vel) -(gf(requested_vel)*(gf(velocity_tol) * 0.01)));
        if(gf(current_vel) > 0.0 && gf(current_vel) >= min_velocity)
            sb(vel_status, true);
        else 
            sb(vel_status, false);

        if(gb(torch_on) && gb(arc_ok) && gb(vel_status))
            { // allow correction
            if((gf(volts) + gf(voltage_tol)) > gf(volts_requested))
                offset -= gf(correction_vel);
            if((gf(volts) - gf(voltage_tol)) < gf(volts_requested))
                offset += gf(correction_vel);
            last_z_in = 0.0;
            }
        if(!gb(torch_on))
            { // remove any offset
            z_diff = gf(z_pos_in) - last_z_in;
            if(z_diff > 0.0 && offset != 0.0)
                { // torch is moving up
                if(offset > 0.0)
                    { // positive offset
                    if(offset > z_diff)
                        // remove some
                        offset -= z_diff;
                    else 
                        offset = 0.0;
                    }
                if(offset < 0.0)
                    { // negative offset
                    if(offset < z_diff)
                        // remove some
                        offset += z_diff;
                    else 
                        offset = 0.0;
                    }
                }
            last_z_in = gf(z_pos_in);
            }
        sf(z_pos_out, gf(z_pos_in) + offset);
        sf(z_fb_out, gf(z_pos_in)); // keep axis motor position fb from being confused
        }
    if(!gb(enable))
        {
        sf(z_pos_out, gf(z_pos_in));
        sf(z_fb_out, gf(z_pos_in)); // keep axis motor position fb from being confused
        }

return 0;
}
