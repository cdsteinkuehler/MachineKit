component thcudv2 "Torch Height Control Up/Down Input";

description
"""
Torch Height Control
This THC takes either an up or a down input from a THC

If enabled and torch is on and X + Y velocity is within tolerance of set speed
allow the THC to offset the Z axis as needed to maintain voltage.

If enabled and torch is off and the Z axis is moving up remove any correction
at a rate not to exceed the rate of movement of the Z axis.

If enabled and torch is off and there is no correction
pass the Z position and feed back untouched.

If not enabled pass the Z position and feed back untouched.

Physical Connections typical
paraport.0.pin-12-in <= THC controller Plasma Up
paraport.0.pin-13-in <= THC controller Plasma Down
parport.0.pin-15-in  <= Plasma Torch Arc Ok Signal
parport.0.pin-16-out => Plasma Torch Start Arc Contacts

HAL Plasma Connections
thc.torch-up <= paraport.0.pin-12-in
thc.torch-down <= paraport.0.pin-13-in
motion.spindle-on => parport.0.pin-16-out (start the arc)
thc.arc-ok <= motion.digital-in-00 <= parport.0.pin-15-in (arc ok signal)

HAL Motion Connections
thc.requested-vel <= motion.requested-vel
thc.current-vel <= motion.current-vel

Pyvcp Connections
In the xml file you need something like:

<checkbutton>
  <text>"THC Enable"</text>
  <halpin>"thc-enable"</halpin>
</checkbutton>
<spinbox>
  <width>"5"</width>
  <halpin>"vel-tol"</halpin>
  <min_>.01</min_>
  <max_>1</max_>
  <resolution>0.01</resolution>
  <initval>0.2</initval>
  <format>"1.2f"</format>
  <font>("Arial",10)</font>
</spinbox>

Connect the Pyvcp pins in the postgui.hal file like this:

net thc-enable thcud.enable <= pyvcp.thc-enable

""";

author "John Thornton";

license "GPLv2 or greater";

option singleton yes;

// Input Pins
pin_ptr in bit torch_up         "Connect to an input pin";
pin_ptr in bit torch_down       "Connect to input pin";
pin_ptr in float current_vel    "Connect to motion.current-vel";
pin_ptr in float requested_vel  "Connect to motion.requested-vel";
pin_ptr in bit torch_on         "Connect to motion.spindle-on";
pin_ptr in bit arc_ok           "Arc Ok from Plasma Torch";
pin_ptr in bit enable           "Enable the THC, if not enabled Z position is passed through";
pin_ptr in float z_pos_in       "Z Motor Position Command in from axis.n.motor-pos-cmd";

// Output Pins
pin_ptr out float z_pos_out     "Z Motor Position Command Out";
pin_ptr out float z_fb_out      "Z Position Feedback to Axis";
pin_ptr out float cur_offset    "The Current Offset";
pin_ptr out bit vel_status      "When the THC thinks we are at requested speed";
pin_ptr out bit removing_offset "Pin for testing";

// Parameters
pin_ptr io float velocity_tol   "The deviation percent from planned velocity";
pin_ptr io float correction_vel "The Velocity to move Z to correct";

// Global Variables
variable hal_float_t offset = 0.0;
variable hal_float_t last_z_in = 0.0;

function _;

;;

#include "rtapi_math.h"

FUNCTION(_)
{
hal_float_t min_velocity;
hal_float_t z_diff;

    if(gb(enable)){
        min_velocity = gf(requested_vel) - (gf(requested_vel) * (1.0 / gf(velocity_tol)));
        if(gf(current_vel) > 0.0 && gf(current_vel) >= min_velocity)
            sb(vel_status, true);
        else 
            sb(vel_status, false);

        if(gb(torch_on) && gb(arc_ok) && gb(vel_status))
            { // allow correction
            if(gb(torch_down))
                offset -= gf(correction_vel);
            if(gb(torch_up))
                offset += gf(correction_vel);
            last_z_in = 0.0;
            }
        if(!gb(torch_on))
            { // remove any offset
            z_diff = gf(z_pos_in) - last_z_in;
            if(z_diff > 0.0 && offset != 0.0)
                { // torch is moving up
                sb(removing_offset, true);
                if(offset > 0)
                    { // positive offset
                    if(offset > z_diff) // remove some
                        offset -= z_diff;
                    else 
                        offset = 0.0;
                }
                if(offset < 0.0)
                    { // negative offset
                    if(offset < z_diff) // remove some
                        offset += z_diff;
                    else 
                        offset = 0.0;
                    }
                }
            else 
                sb(removing_offset, false);
            last_z_in = gf(z_pos_in);
            }
        sf(z_pos_out, gf(z_pos_in) + offset);
        sf(z_fb_out, gf(z_pos_in)); // keep axis motor position fb from being confused
        }
    if(!gb(enable))
        {
        sf(z_pos_out, gf(z_pos_in));
        sf(z_fb_out, gf(z_pos_in)); // keep axis motor position fb from being confused
        }

return 0;
}
